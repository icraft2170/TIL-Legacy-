---
title: 05.27일 ( studylog )
author : 손현호
date: 2021-05-27
---

# 상속(inheritance)

- 기존 클래스의 멤버들을 `extends`라는 예약어를 통해 재사용 할 수 있도록 해주는 것
- `is a` ,  `~은 ~이다` 의 개념으로 하위(자손) 클래스 상위(조상) 클래스에 개념적으로 포함된다. 
- 생성자와 초기화 블럭은 상속되지 않는다.
- 조상의 조상 클래스의 내용도 상속된다.
- 상위 클래스들의 멤버화 본인 클래스의 멤버가 합쳐져 하나의 인스턴스를 생성한다.
- Java에서는 `단일상속`만 지원한다
    - 다중상속은 복잡한 기능을 쉽게 작성한다는 장점이 존재하지만, 다 수의 조상클래스의 같은 이름의 멤버가 존재할 때 구분할 수 없는 문제(Diamond Problem)을 막기 위해 단일 상속만 지원한다.
```java
class Parent{
 /// code 1...
 /// code 2...   
} // 조상클래스, 상위클래스

class Child extends Parent{
 /// code 1... ( inheritance )
 /// code 2... ( inheritance )
 /// code 3...
} //자식클래스,하위클래스
```
#### Object 클래스
    Object클래스는 모든 클래스의 최상위 클래스이다. 상속을 지정하지 않으면 컴파일러가 자동으로 `extends Object`를 추가해준다. 다중상속이 불가능한 자바에서 다른 상속을 받는 클래스는 조상, 조상의 조상 ... 올라가다 보면 조상클래스들 중에 누군가는 Object클래스를 상속받고 있을 것이다.



<br/>

## 1. 상속과 포함

### 포함

- 클래스가 다른 클래스의 참조변수를 멤버로 갖는 것
- `has a` , ` ~은 ~을 가지고 있다`의 개념으로 각 클래스가 개념적으로는 서로 같지 않지만 포함관계가 있을 때 사용한다.

```java

class Engine{
    // code1
}

class Car {
    Engine e = new Engine;
    // Car와 Engine클래스는 포함관계(has a)이다.
}

class SportCar extends Car{
    // code...
    // Car와 SportCar클래스는 상속관계(is ~ a)이다.
}

```



## 오버라이딩(overriding)

- 조상클래스에서 상속받은 메서드의 내용을 수정하는 것을 `오버라이딩`이라고 한다
- 조상클래스의 메서드와 메서드의 `이름, 매개변수, 반환타입`이 같아야 한다.
- 접근 제어자(access modifier)와 예외(exception)는 제한된 조건 내에서 다르게 변결될 수 있다
    - 접근 제어자는 조상클래스 메서드 보다 좁은 범위일 수 없다.
    - 예외는 조상 클래스의 메서드보다 범위,개수등에서 많이 선언 할 수 없다
    - 인스턴스 메서드를 클래스 메서드로 변강하거나 그 반대는 불가능하다.


```java
class Car {
   void go(){
       System.out.println("간다.");
   }
    
}

class SportCar extends Car{
    void go(){
       System.out.println("매우 빠르게 간다.");
   }
}
```

## super / this


### super
- 상속받은 상위클래스의 주소를 저장하고 있는 `참조변수`
- `super(Parameter)`는 상위 클래스의 생성자를 호출 하는 역할을 한다.
- static 메서드(클래스 메서드)에서는 사용 할 수 없다.
- 생성자에 super()키워드가 없을 때는 컴파일러가 자동으로 생성해준다.
    - 만약 상위클래스의 해당 생성자가 없다면, 상위클래스의 생성자에 맞는 형식으로 작성해야만 한다.
### this
- 자기 자신의 인스턴스 주소를 저장하는 `참조변수`
- `this(Parameter)`는 자기 자신의 생성자를 호출 하는 역할을 한다.
- static 메서드(클래스 메서드)에서는 사용 할 수 없다.



---


### Package

- 클래스의 묶음( 클래스와 인터페이스를 포함한다. )
- 파일의 첫 번째 문장으로 단 한 번의 패키지 선언이 가능하다
    - `package 패키지명;`
    - 패키지명은 클래스와의 구분을 위해 `소문자`로 한다.
- 모든 클래스는 하나의 pakage를 갖는다
    - 쓰지 않을 경우 자동으로 자바에서 제공하는. `이름없는 패키지(unnamed package)`에 속한다.


### import
- 다른 패키지의 클래스를 사용하기 위해 클래스패스및 클래스 명을 미리 지정해준다.
- pakage문과 클래스 선언 사이에 존재해야 한다.
    - `import classpath.classname` , `import classpath.*`
    -  *의 역할은 해당 디렉토리에 클래스 전부를 import 하는 것이다. 하위 디렉토리의 클래스는 포함되지 않는다.

#### static import

- static import문은 메서드 사용시에 `클래스.메서드`에서 클래스를 생략 할 수 있도록 한다.

---


## 제어자(modifier)

- 클래스, 변수, 메서드의 선언부에 사용하여 부가적 의미를 부여  
    - 접근제어자 : public protected, default, private
    - 외 : static, final,abstract ...
- 제어자는 하나의 대상에 여러개를 사용 할 수 있는데 접근제어자는 하나의 대상이 하나만 가질 수 있다.

### 접근제어자

    public > protected > (default) > private
    
    public - 접근에 제한이 없다.
    protected - 같은 패키지, 상속관계의 하위클래스들이 접근 가능하다.
    default - 같은 패키지 내에서만 접근 가능하다. ( 기본 생성 )
    private -  같은 클래스 내에서 접근이 가능하다.


이러한 접근제어자는 `캡슐화`를 이루기 위한 중요한 개념으로 클래스 내부 데이터를 보호하고 메서드의 유지보수를 쉽게 만들어준다. 접근제어자를 사용하여 외부 접근의 `데이터 감추기(data hiding)`를 진행하여 외부에 불필요한 부분을 감추고 데이터를 보호할 수 있게 된다. 그리고 추후 메서드의 변경을 진행할 때 변경으로 인해 영향을 미치는 범위를 예상할 수 있게 된다. 만약 public으로 선언된 메서드를 변경하게 된다면 코드 전반을 살펴 봐야할 것이다.

### geter, seter

- 접근제어자로 접근 할 수 없는 멤버변수를 가져오고 저장하는 역할을 하는 메서드로 저장할 때의 조건을 추가하는 것으로 해당 데이터의 유효성을 체크하고 안정성을 높일 수 있다.

### static

- `static`이 붙은 멤버변수 인스턴스와 관계없이 공통적인 값을 갖는다
    - static이 붙은 멤버변수는 클래스 변수라 하여 클래스가 메모리에 로드 될 때 생성된다.
- 멤버변수 ,메서드, 초기화블럭에 사용이 가능하다.

### final

- `final` 이라는 제어자를 사용하게 되면 변경할 수 없다는 의미를 지니게 된다
    - 변수의 경우 중간에 값을 변경 할 수 없는 `상수`가 된다.
    - 메서드의 경우에는 오버라이드(메서드 재정의)를 할 수 없게 된다.
    - 클래스에 사용할 경우 상속을 할 수 없는 클래스가 된다.
- 멤버 변수로 존재하는 `final`은 생성자를 통해 인스턴스마다 다른 값을 갖는 상수를 만들 수 있다.


### abstract

- `추상메서드` ,`추상클래스`를 만드는데 사용된다. 
- 추상 메서드,클래스는 '미완성' 이라는 의미로 구현되지 않은 메서드 혹은 추상 메서드를 포함하고 있는 클래스를 의미한다.
- 이는 상속을 통해 오버라이딩 하여 다형성을 이루기 위해 사용된다.
    - 하나의 자료형으로 하위의 다 수의 자료형을 사용
- 추상클래스는 미완이기 때문에 객체(인스턴스)를 생성할 수 없다.  




    
# 다형성(polymorphism)
- 여러 가지 형태를 가질 수 있는 성질
- Java에서는 하나의 자료형이 다양한 자료형의 인스턴스를 참조할 수 있고록 하여 다영성을 구현하였다.

```Java
class Car {
    //code
}

class SportCar extends Car{
    //code
}

class CarTest{
    public static void main(String[] args*){
        Car car = new SportCar();
        // 조상클래스의 참조형은 자손클래스의 인스턴스를 참조할 수 있다.
        SportCar spCar = new Car();
        // 자손클래스의 참조형은 조상클래스의 인스턴스를 참조할 수 없다.
    }
}

```

> 위 그림에서 SportCar 클래스는 Car 클래스의 상속을 받는다.  Car의 인스턴스를 SportCar참조형으로 받게 되면 SportCar의 참조변수가 사용가능 멤버메서드 및 멤버변수가 <u>Car인스턴스가 사용가능한 멤버메스드 및 멤버변수보다 많거나 같기 때문에 사용할 수 없는 메서드를 실행하게 될 위험성이 존재하기 때문에 참조가 불가능하다.</u> 하지만, 반대의 경우에는 참조변수가 인스턴스가 표현할 수 있는 범위보다 좁기 때문에 참조가 가능하다고 할 수 있다.

<br/><br/>

### 참조변수의 형변환

    하위 -> 상위 (자동형변환 : Up-Casting)
    상위 -> 하위 (명시적형변환 : Down-Casting)

```java
class Car {
    int x = 10;
    //code
}

class SportCar{
    int x = 5;
    //code
}

class CarTest{
    public static void main(String[] args*){
        Car car;
        SportCar spCar = new SportCar();
        Car = SportCar();
        // 자동형변환 , Up-Casting
        // 하위 -> 상위로 형변환 
        SportCar sportcar;
        Car car2 = new Car();
        sportcar = (SportCar)car2;
        // 명시적형변환, Down-Casting
        // 상위 -> 하위로 형변환
        }
}

```


### 상위 -> 하위 클래스로의 형변환

상위 클래스는 상위 클래스를 상속받은 하위클래스`들`의 인스턴스를 모두 참조 할 수 있다. 그런데, 같은 조상을 가지고 있는 하위클래스들은 서로 형변환이 불가능하기 때문에 형변환이 불가능 할 수 도 있다. 그런 부분 때문에 상위클래스에서 하위클래스로의 형변환은 자동 형변환이 불가능하고 명시적으로 진행해줘야 한다. 그 과정에서 컴파일러가 참조변수가 참조하는 인스턴스의 자료형을 알지 못하기 때문에 `instansof()`를 통해 참조변수가 참조하는 인스턴스의 자료형을 파악하는 방법으로 `유효성검사`를 진행하고 다운캐스팅을 하는 것이 안전하다. 

<br/>

## 가상 메서드


자바의 클래스는 멤버변수와 메서드로 이루어 진다. 그런데, 메모리에서 멤버 변수와 메서드는 서로 다른 곳에 생성이 된다. 멤버변수는 인스턴스마다 각각 다른 값을 가지지만 메서드의 경우 동일한 기능을 각각의 인스턴스가 공유하기 때문에 메서드메모리의 코드영역에 생성되어 함수의 이름을 통해 연결된다.  

그런데 위와 같이 상속을 받아 오버라이딩을 하면 이름이 같은 메서드가 다수 생기고 이런 상황에 메서드를 찾을 때는 참조변수와 인스턴스의 자료형에 따라 다르게 작용한다. 이렇게 메서드가 자신의 위치를 찾아가는 기술을 `가상메서드`라고 한다.



```java
class Car {
    int x = 10;
    void go(){/*code 1 */}
    //code
}

class SportCar{
    int x = 5;
    void go(){/*code 2 */}
    //code
}

class CarTest{
    public static void main(String[] args*){
            Car car = new SportCar();
            System.out.println(car.x);
            // x = 10...
            car.go();
            // 함수 go의 code 2가 실행된다.
        }
}

```


- `Car car = new SportCar();`
    - 참조형이 조상이고 인스턴스가 자손인 경우 이름이 같은 멤버변수가 존재 할 때 참조변수의 자료형을 따른다 하지만, 메서드는 오버라이딩 한 경우에 인스턴스형을 따른다. 
- 멤버변수의 이름이 다른 경우에는 인스턴스형에만 존재하는 멤버변수에는 접근할 수 없고 참조변수의 멤버변수에만 접근이 가능하다.

<br/><br/>

### 다양한 자료형을 하나의 객체 배열로 다루기

```java
Car[] car = new Car[10];
car[1] = new SportCar();
car[2] = new OpenCar();
car[3] = ...
// 생략 ...
```

위와 같이 Car라는 상위클래스로 선언한 배열 하나로 자손 클래스들의 여러 인스턴스를 다룰 수 있다. 


### Vertor()

- 위 `car의 배열`은 한번 선언하면 크기를 변경하기 복잡하다. 그렇다고 처음 부터 무작정 배열의 크기를 크게 설정할 수도 없다. 이 때 <u> `Vector 클래스` </u>를 사용하면 유용하다. 내부적으로 Object타입의 배열을 가지고 있어서 모든 객체를 추가하거나 제거할 수 있도록 작성되어 있다. 그리고 배열의 크기를 알아서 관리해준다는 장점도 있다.


| 메서드/생성자 | 설명 |
|:----:|-------------------------------|
Vector()| 10개의 객체를 저장하는 Vector인스턴스를 생성한다, 크기가 자동증가
boolean add(Object o)|Vector에 객체를 추가 성공시 True, 실패시 False를 반환
boolean remove(Object o)|Vector에 객체를 삭제 성공시 True, 실패시 False를 반환
boolean isEmpty()| Vector가 비어있는지 검사 비어있으면True 아니면 False
Object get(int index)| 지정덴 index의 객체를 반환
int size()| Vector에 저장된 객체의 개수를 반환





<br/><br/>

---



<br/><br/>

## 추상클래스

#### 추상
    추상화 - 클래스간의 공통점을 찾아내서 공통의 조상을 만드는 작업
    구체화 - 상속을 통해 클래스를 구현, 확장하는 작업

상속은 자손 클래스를 만드는데 조상 클래스를 이용하는 것이라면, 이와 반대로 추상화는 기존의 클래스의 `공통점을 뽑아 조상 클래스`를 만드는 것이다.   
<<u> 이는 같은 공통점을 가진 자손클래스들을 한번에 사용할 수 있는 조상클래스를 만드는 작업 </u>>

- 상속계층도를 타고 내려갈수록 구체화가 심해지고 올라갈 수록 추상화의 정도가 심해진다.

### 추상 클래스
- 추상 메서드를 포함하고 있는 클래스를 추상 클래스라고 한다
- 추상 클래스는 인스턴스화 할 수 없다. (new를 통해 인스턴스 생성 불가)
- 참조변수의 자료형으로 사용하여 하위 클래스를 참조할 수는 있다.
- 추상클래스는 class이름 앞에 `abstract`을 붙여 주면된다. 
- 추상메서드를 포함하지 않아도 abstract을 붙여 추상클래스로 만들 수 있는데, 이럴 경우 이 클래스는 인스턴스화 할 수 없다.
- 모든 메서드가 공통적으로 사용할 내용이라면 구현해도 좋다.

<사견 : 메서드를 구현할 수 있다는 건 인터페이스로부턴 구현한 추상클래스가 클래스에서 공통점들을 뽑아 구현해야할 필수적인 클래스를 줄여줄 수 있다.>


### 추상 메서드
- 추상 메서드는 선언부만 작성하고 구현부를 작성하지 않은 미완성 메서드이다.
    - 추상메서드를 상속받은 자손클래스에서 구현 해야하며, 구현하지 않은 추상메서드가 있는 자손클래스는 추상클래스로 지정해 주어야 한다.
- 상속받는 클래스에서 구현을 하도록 하며 반드시 구현을 해야할 공통점들을 선언하는 의미를 갖는다.
    - 추상메서드는 메서드를 사용하는 쪽에서 메서드의 구현부를 몰라도 선언부와 기능만으로 충분히 사용할 수 있다. (ex. jre가 제공하는 기본 메서드를 사용하는것과 동일./ 일종의 설명서 역할)

<br/><br/>


```java

abstract class Unit{
	int x,y;
	abstract void move(int x, int y);
	void stop() { /*정지*/}
}


class Marine extends Unit{

	@Override
	void move(int x, int y) {/* 빠르게 걸어서 이동 */}
	// 오버라이드를 통해 같은 일을 다른 방법으로 진행
    void stimpack() {}
}


class Dropship extends Unit{

	@Override
	void move(int x, int y) {/*하늘을 날아 이동한다*/}
	// 오버라이드를 통해 같은 일을 다른 방법으로 진행 
    void load() {}
	void upLoad() {}
}


public class UnitTest {
    Unit[] unit = new Unit[2];
    unit[0] = new Marine();
    unit[1] = new Dropship();
    for(Unit u: unit){
        u.move(30,50);
    }
    // 추상클래스의 자료형으로 공통적인 move라는 메서드를 실행 시킬 수 있다.
    // 추상클래스에 메서드로 move, stop만 정의되어 있기 때문에 공통점만 사용할 수 있다.
}

```




