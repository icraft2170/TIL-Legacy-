---
title: 05.26일 ( studylog )
author : 손현호
date: 2021-05-26
---

## JVM의 메모리 구조

 ### 3가지 주요 영역 구조


 1. Method Area (+ Datas Area)
    - Class datas
 1. Call Stack
 1. Heap
    - instance


---


### 1. 메서드 영역(method area)
- JVM은 클래스가 사용되면, 클래스 파일에 있는 정보를 메서드 영역에 저장한다. 클래스 변수(Static으로 클래스 내부에 선언된 변수)도 이 영역에 생성된다.

### 2. 힙(heap)
- new 예약어를 통해 인스턴스(객체, 인스턴스 변수) 생성되는 공간 

### 3. 호출 스택 (call stack or execution stack)
- 메서드가 작업에서 필요한 메모리 공간으로, 메서드 사용시 메서드의 메모리공간, 지역변수, 매개변수, 연산의 중간 값등을 저장 실행 되면 밑에서 부터 위 쪽으로 메모리공간이 마련되며, 맨 위에 마련되어 있는 메모리 공간이 현재 사용중인 메모리 공간이고 외에는 대기상태로 있게 됨.

```java
public class CallStackTest {

	public static void main(String[] args) {
		System.out.println("메인메서드 시작");
		firstMethod();
		System.out.println("메인메서드 끝");
	}
	
	static void firstMethod() {
		System.out.println("첫 메서드 시작");
		secondMethod();
		System.out.println("첫 메서드 끝");
		// return; ( 자동 생성 )
	}
	
	static void secondMethod() {
		System.out.println("두번째 메서드 시작");
		System.out.println("두번째 메서드 끝");
		// return; ( 자동 생성 )
	}
	
}

```
결과 값
>메인메서드 시작  
>첫 메서드 시작  
>두번째 메서드 시작  
>두번째 메서드 끝  
>첫 메서드 끝  
>메인메서드 끝  


</br></br></br>


---
</br></br></br>



## 메서드의 매개변수(Parameter)

</br>

메서드에서 매개변수는 메서드가 호출 될 때 값을 매개변수에 복사하여 전달 한다. 이 때, 매개변수가 기본자료형이면 그 값을 복사해서 전달하는 것으로 변수 값을 읽기만 할 수 있지만, `참조 변수`에 경우에는 그 값이 주소 이기 때문에. <u>주소를 통해 접근하여 읽고/쓰는 것이 가능하다.</u>

</br>

```java

public class ReturnT {

	public static void main(String[] args) {
		int[] intArr = { 1, 3, 5, 7, 9, 11};
		
		// 두 숫자를 인자로한 add
		int sum = add(3, 5);
		System.out.printf("sum : %d\n", sum);
		
		// 참조변수(배열)을 인자로 한 add(int num, int[] intArr)
		add(1, intArr);
		
		
		for(int i=0;i<intArr.length;i++) {
			System.out.printf("intArr[%d] : %d \t", i, intArr[i]);
		}	
	
	}
	static int add(int num1, int num2) {		
		return num1 + num2;
	}
	
	static void add(int num, int[] intArr) {
		for(int i=0;i<intArr.length;i++) {
			intArr[i] += num;
		}
	}
	
}


```
결과 

>sum : 8  
>intArr[0] : 2  intArr[1] : 4 	intArr[2] : 6 	intArr[3] : 8 	intArr[4] : 10 	intArr[5] : 12 	


위 예제를 통해 원래 메서드는 단 하나의 `return` 값을 가질 수 있는데, 참조 형 변수인 배열을 인자로 하여 마치 많은 `return`값을 갖는 것과 같은 효과를 얻을 수 있다.



---


## 재귀호출 (recursive call)

```java
void function(){
	function();
}
// 재귀메서드
```
메서드가 스스로를 다시 호출하는 것을 재귀호출 이라고 한다. 다만, 위와 같이 선언하면 무한반복에 빠져 버리기 때문에 아래와 같이 메서드를 빠져나갈 조건문이 필수적이다.

```java
void function(){
	if(조건) return;
	function();
}
```

이러한 재귀호출은 반복문으로 치환이 가능한데, 재귀호출 보다 반복문에 수행시간이 평균적으로 적게 걸린다. 그럼에도 불구하고 재귀호출을 사용 하는 이유는 `논리적 간결함` 때문이다. 단순한 구조로 바꾸어 `가독성` 높일 수 있다는 점이 이유라고 할 수 있다.

---

## 클래스 메서드(static메서드)와 인스턴스 메서드

#### 클래스 메서드
- 메서드 앞에 static이 붙어있는 메서드
- 프로그램이 시작할 때 생성되는 메서드
- 객체 생성 없이 사용 가능한 메서드

#### 인스턴스 메서드
- 객체를 생성해야만 사용할 수 있는 메서드
- 인스턴스 변수와 관련된 작업을 진행하는 메서드


클래스 메서드와 인스턴스 메서드를 나누는 방법은 문법적으로는 `static`이라는 예약어를 사용 했는지 여부이다. `static`으로 선언된 메서드 및 변수들은 프로그램이 시작할 때 이미 생성 되고 프로그램이 끝날때 사라지기 때문에 객체를 생성하지 않아도 사용할 수 있는 것이다. 그 때문에 인스턴스를 생성해야만 사용할 수 있는 인스턴스 변수를 포함 할 수 없다. 그래서 클래스 메서드와 인스턴스 메서드중 어느 쪽을 사용할지 여부는 인스턴스 변수와 관련된 작업을 하는지 여부이다. 
※ <u> 인스턴스 메서드보다 클래스 메서드의 호출시간이 평균적으로 더 짧다. </u>









---



## 오버로딩(Overloading)

	오버로딩은 같은 클래스 내에서 메서드의 이름이 같고 매개변수의 개수 or 타입 or 순서 가 다른 메서드를 여러개 정의하는 것을 오버로딩 이라고 한다

#### 오버로딩의 조건
- 매개변수의 개수가 다르다
	- 매개변수의 개수가 다른 두 메서드는 서로 구분하여 사용이 가능하기 때문에 오버로딩이 가능하다.
	- ex) add(int a, int b) , add(int a, int b, int c)
- 매개변수의 타입이 다르다
	- 매개변수의 개수가 같지만 두 메서드의 매개변수가 서로 타입이 다르다면 오버로딩이 가능하다.
	- ex) add(int a, int b) , add(long a, long b)
- 매개변수의 순서가 다르다.
	- 매개변수의 타입과 개수가 같지만 순서가 다르다면 오버로딩이 가능하다
	- ex) add(int a long b) , add(long b int a)
	- 이 경우에는 문제가 생길 수 있다. 만약 add(3,4)와 같이 사용했을 때 둘중 어느쪽을 사용할지 컴파일러가 찾을 수 없기 때문이다.


#### 오버로딩의 장점
- 같은 기능을 하는 다양한 타입,개수의 메서드를 하나의 이름으로 정의 가능
- 메서드 이름을 절약 할 수 있다.

<br/>

### 가변인자
- 파라미터를 `타입... 변수명`으로 지정해줌으로서 인자의 개수를 동적으로 사용할 수 있다.

```java
	public void function(String... str){
				// 생략
	}
```

와 같이 사용하면 `function`이라는 메서드는 아래와 같이 호출하는것이 가능해 진다

```java
function();
function("손");
function("현","호");
function(new String[] {"입","니","다"});
```
간단하게 얘기하면 가변인자라는 것읏 원하는 타입의 변수를 개수의 제한없이 인자로 받을 수 있는 것을 얘기한다.
이러한 가변인자는 선언할 때 가변인자 외의 인자가 존재한다면 반드시 <u> 가장 뒤에 위치 해야한다.</u>

가변인자는 위와 같이 인자의 개수가 0개여도, 배열이어도 상관없다. 그 이유는 가변인자가 배열로 만들어져 있기 때문이다.   
>자바에서 배열의 개수는 0개일 수 있음 / 가변인자의 사용은 편하지만 비효율적이다.



---

## 생성자(Constructor)


- 인스턴스가 생성될 때 호출되어 인스턴스를 초기화하는 메서드
- 메서드와 비슷한 구조를 가졌으나 반환값이 존재하지 않다는 점이 메서드와 다르다
- 생성자는 클래스와 이름이 같아야 하고, 오버로딩이 가능하다.


### 기본 생성자(default constructor)

<br/>

모든 클래스에는 하나 이상의 클래스가 생성되어 있어야 하지만 클래스 내부에 생성자를 지정해주지 않으면 컴파일러에서 `기본생성자`를 지정하는데 기본 생성자의 내용은 아래와 같이 파라미터도 구현부의 어떤 내용도 존재하지 않는다.

```java
className(){/*내용 없음*/ }
```

다만 ,  <u>기본 생성자는 클래스 내부에 생성자가 하나도 존재하지 않을 때 생성되기 때문에</u> 만약 생성자가 클래스 내부에 존재한다면 컴파일러는 기본 생성자를 제공하지 않는다. 따라서 명시적으로 파라미터가 없는 생성자를 지정해 주지 않는다면 반드시 인자를 지정하여 생성자를 호출 해야한다.



### this , this()

- `this`는 참조변수로 인스턴스 자신을 가르킨다.
- 생성자의 파라미터와 멤버변수를 구분하는 역할로 사용한다.
- 생성자 내부에서 생성자를 호출하는 역할로 사용한다.
	- 생성자 내부에서 생성자를 호출 할 때는 반드시 맨 앞에 this()를 통해 호출을 해줘야 한다.
- 생성자를 포함한 모든 인스턴스메서드에는 `this`가 지역변수로 숨겨진채 존재한다.
- `this`는 참조변수 `this()` 생성자로 서로 다르다.

```java
int parameter01;
String parameter02;

/*
public Constructor(){
	int parameter01 =3;
	//error 생성자 내부에서 생성자를 호출할 때에는 가장 앞에서 호출 해줘야 한다.
	this(8,"Java")
}
*/

public Constructor(){
	this(8,"Java")
	// 같은 클래스 내의 생성자를 호출 하였다.
}
public Constructor(int parameter01, String parameter02){
	this.parameter01 = parameter01;
	this.parameter02 = parameter02;
// 멤버변수와 파라미터의 구분을 위해 this를 사용해 주었다.
}
```


---

## 변수의 초기화

- 멤버 변수와 배열은 초기화를 하지 않아도 기본값으로 자동으로 초기화가 진행된다.
- 지역변수는 사용 전 반드시 초기화가 진행되어야 한다.

|자료형|기본값|
|:----:|:----:|
boolean| false
char| '\u0000'
byte,short,int|0
long|0L
float|0.0f
double|0.0
참조형변수| null

- 명시적 초기화
	- (자료형) (변수명) = (값)
- 초기화 블럭
	- 클래스 초기화 블럭
		- `static { /* 복잡한 클래스 초기화 내용 */ }`
		- 프로그램이 실행될 때 한 번만 실행된다.
	- 인스턴스 초기화 블럭
		- ` { /* 복잡한 인스턴스 초기화 내용 */ }`
		- 인스턴스가 생성 될 때 마다 실행된다.
		- 생성자보다 우선적으로 실행되며 모든 인스턴스가 공통으로 수행해야 하는 코드를 넣는데 사용 한다.
	- 초기화 블럭 내부에는 조건문,반복문,예외처리구문 등을 자유롭게 사용 가능.

```java

// 클랙스 초기화 블럭
static{
	System.out.println("프로그램이 시작할 때 가장 먼저 실행");
	System.out.println("내부에서 이용할 수 있는 변수는 클래스 변수 뿐이다.(static 변수)");
}


//인스턴스 초기화 블럭
{	
	System.out.println("인스턴스가 생성 될 때 마다. 생성자보다 우선적으로 실행된다."); 
}


```
#### 멤버변수의 초기화 순서

> 클래스변수의 초기화 순서 [ 기본 값 -> 명시적 초기화 -> 클래스 초기화 블럭]
> 인스턴스변수의 초기화 순서 [기본 값 -> 명시적 초기화 -> 인스턴스 초기화 블럭 -> 생성자]
